
(** Function declaration decisions

    This defines the kind of decisions that can take place
    when processing a function delcaration.
    Closure decides during the declaration fo a function
    whether all its direct call will be inlined or not.
    On the other hand, flambda1 delays this decision until
    each call, deciding whether to inline depending on the
    estimated benefits of inlining according to the context.
*)

(* Type definitions *)
(* ************************************************************************* *)


type flambda2_inline_reason =
  | Attribute
  (** An attribute on the function declaration directed to
      inline the function. *)
  | Size of {
      body_size : int;
      size_threshold : Inlining_threshold.t;
    }
  (** Without attributes, the size of the function's body
      was computed, and was lower than the threshold, and
      thus the function will be inlined. *)
(** The reasons why fladba2/closure decides to inline a
    function. *)

type decision =

  (* Flambda1 *)

  | No_decision_flambda1
  (** As stated above, flambda1 does not make any decision
      at function declaration time. *)


  (* Flambda2 *)

  | Never_inline_attribute
  (** An attribute [@inline never] was on the declaration *)
  | Function_body_too_large of Inlining_threshold.t
  (** The function's body size was larger than the inlining
      threshold. According to closure's startegy, this is the
      deciding factor for whether to inline a function, and
      thus the function will not be inlined. *)
  | Stub
  (** Function is a stub, most likely generated by the compiler
      at some points. It is very much desirable to inline it
      if we know that information. *)
  | Inline of flambda2_inline_reason
  (** The flambda2/closure inliner has decided to inline the
      function, because of the given reason. *)


type t = {
  code_id : Code_id.t;
  before_simplify : decision;
  after_simplify : decision;
}
(** The decision that can be made when processing the declaration
    of a function (identified by its code_id).
    Flambda2 performs two passes on each function declaration,
    once before simplification, and a second pass after
    simplification. Since that distinction also makes sense for
    other inlining strategies, this distinction is kept here. *)


(* Convenience wrappers *)
(* ************************************************************************* *)

let can_inline t =
  match t with
  | No_decision_flambda1 -> true
  | Never_inline_attribute
  | Function_body_too_large _ -> false
  | Stub
  | Inline _ -> true

(* Printing *)
(* ************************************************************************* *)

let print_decision_reason fmt = function
  | No_decision_flambda1 ->
    Format.fprintf fmt "%a"
      Format.pp_print_text "flambda1 does not make decisions at \
                            the declaration of functions"
  | Never_inline_attribute ->
    Format.fprintf fmt "%a"
      Format.pp_print_text "the function has an attribute preventing its inlining"
  | Function_body_too_large threshold ->
    Format.fprintf fmt "the@ function's@ body@ is@ too@ large,@ \
                        more@ specifically,@ it@ is@ larger@ than@ the@ threshold:@ %a"
      Inlining_threshold.print threshold
  | Stub ->
    Format.fprintf fmt "the@ function@ is@ a@ stub"
  | Inline Attribute ->
    Format.fprintf fmt "the@ function@ has@ an@ attribute@ forcing@ its@ inlining"
  | Inline Size { body_size; size_threshold; } ->
    Format.fprintf fmt "the@ function's@ body@ is@ smaller@ \
                        than@ the@ threshold:@ size=%d < threshold=%a"
      body_size Inlining_threshold.print size_threshold

let print_decision fmt t =
  Format.fprintf fmt "@[<v>The function %s be inlined at its use-sites@ \
                      because @[<hov>%a@]@]"
    (if can_inline t then "can" else "cannot") print_decision_reason t

